<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.35">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/logo/cpp.svg"><meta name="keywords" content="C++,vuepress,markdown,github pages"><title>导航 | Hello C++</title><meta name="description" content="blog for C++">
    <link rel="modulepreload" href="/Hello-Cpp/assets/app.2859fef2.js"><link rel="modulepreload" href="/Hello-Cpp/assets/sift.html.2a9cda20.js"><link rel="modulepreload" href="/Hello-Cpp/assets/sift.html.da5c1822.js">
    <link rel="stylesheet" href="/Hello-Cpp/assets/style.b14b7022.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/Hello-Cpp/" class=""><!----><span class="site-name can-hide">Hello C++</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/Hello-Cpp/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Base"><span class="title">Base</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Base"><span class="title">Base</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>C++11</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cxx11/lambda.md" class="" aria-label="Lambda 表达式"><!--[--><!--]--> Lambda 表达式 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cxx11/std_function_bind.md" class="" aria-label="function / std::bind"><!--[--><!--]--> function / std::bind <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cxx11/lvalue_rvalue.md" class="" aria-label="右值引用"><!--[--><!--]--> 右值引用 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cxx11/variadic_templates.md" class="" aria-label="可变参数模板"><!--[--><!--]--> 可变参数模板 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>STL</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/STL/vector.md" class="" aria-label="vector"><!--[--><!--]--> vector <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/STL/stack.md" class="" aria-label="stack"><!--[--><!--]--> stack <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Tools"><span class="title">Tools</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Tools"><span class="title">Tools</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>C++11</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cmake/compile-executable_file.md" class="" aria-label="编译可执行文件"><!--[--><!--]--> 编译可执行文件 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cmake/compile-library.md" class="" aria-label="编译库"><!--[--><!--]--> 编译库 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>3rdparty</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/3rd_patry/opencv/opencv.md" class="router-link-active" aria-label="Opencv"><!--[--><!--]--> Opencv <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/3rd_patry/glog/glog.md" class="" aria-label="glog"><!--[--><!--]--> glog <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/3rd_patry/gflags/gflags.md" class="" aria-label="gflags"><!--[--><!--]--> gflags <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/HenryZhuHR/Hello-Cpp" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/Hello-Cpp/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Base"><span class="title">Base</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Base"><span class="title">Base</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>C++11</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cxx11/lambda.md" class="" aria-label="Lambda 表达式"><!--[--><!--]--> Lambda 表达式 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cxx11/std_function_bind.md" class="" aria-label="function / std::bind"><!--[--><!--]--> function / std::bind <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cxx11/lvalue_rvalue.md" class="" aria-label="右值引用"><!--[--><!--]--> 右值引用 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cxx11/variadic_templates.md" class="" aria-label="可变参数模板"><!--[--><!--]--> 可变参数模板 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>STL</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/STL/vector.md" class="" aria-label="vector"><!--[--><!--]--> vector <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/STL/stack.md" class="" aria-label="stack"><!--[--><!--]--> stack <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Tools"><span class="title">Tools</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Tools"><span class="title">Tools</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>C++11</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cmake/compile-executable_file.md" class="" aria-label="编译可执行文件"><!--[--><!--]--> 编译可执行文件 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/cmake/compile-library.md" class="" aria-label="编译库"><!--[--><!--]--> 编译库 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>3rdparty</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/3rd_patry/opencv/opencv.md" class="router-link-active" aria-label="Opencv"><!--[--><!--]--> Opencv <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/3rd_patry/glog/glog.md" class="" aria-label="glog"><!--[--><!--]--> glog <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/Hello-Cpp/3rd_patry/gflags/gflags.md" class="" aria-label="gflags"><!--[--><!--]--> gflags <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/HenryZhuHR/Hello-Cpp" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">导航 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/Hello-Cpp/3rd_patry/opencv/sift/sift.html#寻找极值点" class="router-link-active router-link-exact-active sidebar-item" aria-label="寻找极值点"><!--[--><!--]--> 寻找极值点 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Hello-Cpp/3rd_patry/opencv/sift/sift.html#极值点精确定位" class="router-link-active router-link-exact-active sidebar-item" aria-label="极值点精确定位"><!--[--><!--]--> 极值点精确定位 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Hello-Cpp/3rd_patry/opencv/sift/sift.html#去除边缘影响" class="router-link-active router-link-exact-active sidebar-item" aria-label="去除边缘影响"><!--[--><!--]--> 去除边缘影响 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Hello-Cpp/3rd_patry/opencv/sift/sift.html#确定描述子采样区域" class="router-link-active router-link-exact-active sidebar-item" aria-label="确定描述子采样区域"><!--[--><!--]--> 确定描述子采样区域 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/Hello-Cpp/3rd_patry/opencv/sift/sift.html#opencv-函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="OpenCV 函数"><!--[--><!--]--> OpenCV 函数 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="导航" tabindex="-1"><a class="header-anchor" href="#导航" aria-hidden="true">#</a> 导航</h1><ul><li><a href="#%E5%AF%BC%E8%88%AA">导航</a></li><li><a href="#%E5%9B%BE%E5%83%8F%E5%B0%BA%E5%BA%A6%E7%A9%BA%E9%97%B4">图像尺度空间</a></li><li><a href="#%E5%B0%BA%E5%BA%A6%E7%A9%BA%E9%97%B4%E8%A1%A8%E8%BE%BE%E9%AB%98%E6%96%AF%E5%8D%B7%E7%A7%AF">尺度空间表达：高斯卷积</a></li><li><a href="#%E9%87%91%E5%AD%97%E5%A1%94%E5%A4%9A%E5%88%86%E8%BE%A8%E7%8E%87%E8%A1%A8%E8%BE%BE-%E9%99%8D%E9%87%87%E6%A0%B7">金字塔多分辨率表达-降采样</a></li><li><a href="#loglaplassian-of-gaussian">LOG（Laplassian of Gaussian）</a></li><li><a href="#dogdifference-of-gaussian">DOG（Difference of Gaussian）</a></li><li><a href="#dog%E5%B1%80%E9%83%A8%E6%9E%81%E5%80%BC%E7%82%B9">DOG局部极值点</a><ul><li><a href="#%E5%AF%BB%E6%89%BE%E6%9E%81%E5%80%BC%E7%82%B9">寻找极值点</a></li><li><a href="#%E6%9E%81%E5%80%BC%E7%82%B9%E7%B2%BE%E7%A1%AE%E5%AE%9A%E4%BD%8D">极值点精确定位</a></li><li><a href="#%E5%8E%BB%E9%99%A4%E8%BE%B9%E7%BC%98%E5%BD%B1%E5%93%8D">去除边缘影响</a></li></ul></li><li><a href="#%E6%96%B9%E5%90%91%E8%B5%8B%E5%80%BC">方向赋值</a></li><li><a href="#%E5%85%B3%E9%94%AE%E7%82%B9%E6%8F%8F%E8%BF%B0">关键点描述</a><ul><li><a href="#%E7%A1%AE%E5%AE%9A%E6%8F%8F%E8%BF%B0%E5%AD%90%E9%87%87%E6%A0%B7%E5%8C%BA%E5%9F%9F">确定描述子采样区域</a></li></ul></li><li><a href="#%E7%94%9F%E6%88%90%E6%8F%8F%E8%BF%B0%E5%AD%90">生成描述子</a></li><li><a href="#%E7%94%9F%E6%88%90%E7%89%B9%E5%BE%81%E5%8C%B9%E9%85%8D%E7%82%B9">生成特征匹配点</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%99%A8">使用特征检测器</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86">代码部分</a><ul><li><a href="#opencv-%E5%87%BD%E6%95%B0">OpenCV 函数</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li></ul><p>两张照片之所以能匹配得上，是因为其特征点的相似度较高。</p><h1 id="图像尺度空间" tabindex="-1"><a class="header-anchor" href="#图像尺度空间" aria-hidden="true">#</a> 图像尺度空间</h1><p>不同的<code>尺度</code>去观测照片，尺度越大，图像越模糊</p><p><code>尺度</code>就是二维高斯函数当中的σ值，一张照片与二维高斯函数卷积后得到很多张不同σ值的高斯图像，这就好比你用人眼从不同距离去观测那张照片。所有不同尺度下的图像，构成单个原始图像的尺度空间。<code>图像尺度空间表达</code>就是图像在所有尺度下的描述。</p><blockquote><p>尺度是自然客观存在的，不是主观创造的。<br> 高斯卷积只是表现尺度空间的一种形式。</p></blockquote><h1 id="尺度空间表达-高斯卷积" tabindex="-1"><a class="header-anchor" href="#尺度空间表达-高斯卷积" aria-hidden="true">#</a> 尺度空间表达：高斯卷积</h1><p>高斯核是唯一可以产生多尺度空间的核。在低通滤波中，高斯平滑滤波无论是时域还是频域都十分有效。我们都知道，高斯函数具有五个重要性质：</p><ul><li>二维高斯具有旋转对称性；</li><li>高斯函数是单值函数；</li><li>高斯函数的傅立叶变换频谱是单瓣的；</li><li>高斯滤波器宽度(决定着平滑程度)是由参数σ表征的，而且σ和平滑程度的关系是非常简单的；</li><li>二维高斯滤波的计算量随滤波模板宽度成线性增长而不是成平方增长。</li></ul><p>一个图像的尺度空间 $L(x,y,\sigma)$ ，定义为原始图像 $I(x,y)$ 与一个可变尺度的二位高斯函数 $G(x,y,\sigma)$ 的卷积运算</p><p>二维空间高斯函数表达式为 $ \begin{aligned} G(x_i,y_i,\sigma)=\frac{1}{2\pi\sigma^2}\exp(-\frac{(x-x_i)^2+(y-y_i)^2}{2\sigma^2}) \end{aligned} $</p><p><strong>图像的尺度空间</strong>是<strong>二维高斯函数与原始图像卷积运算后的结果</strong> $ \begin{aligned} L(x,y,\sigma)=G(x,y,\sigma)\ast I(x,y) \end{aligned} $ 二维高斯函数在数学坐标系下的图像： <img src="/Hello-Cpp/assets/二维高斯函数在数学坐标系下的图像.bbb2fa9b.png" alt="二维高斯函数在数学坐标系下的图像"></p><p>高斯函数对应的高斯核： <img src="/Hello-Cpp/assets/高斯函数对应的高斯核.2738bf12.png" alt="高斯函数对应的高斯核"></p><p>高斯核是圆对称的，在图片像素中展现出来的是一个正方形，其大小由高斯模板确定。卷积的结果使原始像素值有最大的权重，距离中心越远的相邻像素值权重也越小。</p><blockquote><p>高斯模糊与“尺度空间表达”的关系？</p></blockquote><p>“尺度空间表达”指的是不同高斯核所平滑后的图片的不同表达，意思就是：原始照片的分辨率，和经过不同高斯核平滑后的照片的分辨率是一样的。但是，对于计算机来说，不同模糊程度，照片“看”上去的样子就不一样了。高斯核越大，图片“看”上去就越模糊。</p><p>那么，图片的模糊与找特征点有关系吗？</p><p>计算机没有主观意识去识别哪里是特征点，它能做的，只是分辨出变化率最快的点。彩色图是三通道的，不好检测突变点。需要将RGB图转换为灰度图，此时灰度图为单通道，灰度值在0~255之间分布。</p><p>无论人眼观测照片的距离有多远，只要能辨认出物体关键的轮廓特征，那就可以大致知道图像所表达的信息。计算机也一样，高斯卷积之后，图像虽然变模糊了。但是整体的像素没有变，依然可以找到灰度值突变的点。</p><p>而这些点，就可以作为候选特征点了，后期再进一步减少点的数量，提高准确率即可。</p><h1 id="金字塔多分辨率表达-降采样" tabindex="-1"><a class="header-anchor" href="#金字塔多分辨率表达-降采样" aria-hidden="true">#</a> 金字塔多分辨率表达-降采样</h1><p>这个比较好理解，若对一张图片进行降采样，其像素点就会减少，图片尺寸也会随之变小。那么给人的感觉就好比一个金字塔。</p><p><strong>图像金字塔化</strong>的步骤：就是先进行图像平滑(高斯模糊)，再进行降采样，根据降采样率不同，所得到一系列尺寸逐渐减小的图像。</p><p><img src="/Hello-Cpp/assets/tri.bd6d8725.png" alt="tri"></p><p>两种表达的不同之处在于：</p><ul><li>“尺度空间表达”在所有尺度上具有相同分辨率，而“图像金字塔化”在每层的表达上分辨率都会减少固定比率。</li><li>“图像金字塔化”处理速度快，占用存储空间小，而“尺度空间表达”刚好相反。</li></ul><p><img src="/Hello-Cpp/assets/log-1.3d52ca0e.png" alt="log-1"><img src="/Hello-Cpp/assets/log-2.5b7d2079.png" alt="log-2"></p><h1 id="log-laplassian-of-gaussian" tabindex="-1"><a class="header-anchor" href="#log-laplassian-of-gaussian" aria-hidden="true">#</a> LOG（Laplassian of Gaussian）</h1><p>如上所述， “尺度空间表达”和 “图像金字塔化”各有各的优势。那么将两者融合起来的话，就得到了LOG图像（高斯拉普拉斯变换图像）。其步骤是：先将照片降采样，得到了不同分辨率下的图像金字塔。再对每层图像进行高斯卷积。这样一来，原本的图像金字塔每层只有一张图像，而卷积后，每层又增加了多张不同模糊程度下的照片。</p><p>然而，LOG图像还不是我们想要的，我们做那么多就是为了更好地获取特征点，所以还需要对LOG图像再进一步地优化。所以，DOG图像横空出世！！</p><h1 id="dog-difference-of-gaussian" tabindex="-1"><a class="header-anchor" href="#dog-difference-of-gaussian" aria-hidden="true">#</a> DOG（Difference of Gaussian）</h1><p>构造高斯差分图像的步骤是：在获得LOG图像后，用其相邻的图像进行相减，得到所有图像重新构造的金字塔就是DOG金字塔。</p><p>图左边是LOG图像，图右边是DOG图像 <img src="/Hello-Cpp/assets/log-dog.c7fcf1b7.png" alt="图左边是LOG图像，图右边是DOG图像"></p><p>当得到DOG金字塔后，我们接下来要做的是寻找DOG极值点。每个像素点与其周围的像素点比较，当其大于或者小于所有相邻点时，即为极值点。</p><p>比如说，如下图所示，以x点为检测点，那么其周围的点，除了同层所包围的8个绿点外，还有上一层的9个点与下一层的9个点。</p><h1 id="dog局部极值点" tabindex="-1"><a class="header-anchor" href="#dog局部极值点" aria-hidden="true">#</a> DOG局部极值点</h1><h2 id="寻找极值点" tabindex="-1"><a class="header-anchor" href="#寻找极值点" aria-hidden="true">#</a> 寻找极值点</h2><p>当得到DOG金字塔后，我们接下来要做的是寻找DOG极值点。每个像素点与其周围的像素点比较，当其大于或者小于所有相邻点时，即为极值点。</p><p>比如说，如下图所示，以黄点为检测点，那么其周围的点，除了同层所包围的8个绿点外，还有上一层的9个点与下一层的9个点。</p><p><img src="/Hello-Cpp/assets/DOG寻找极值点.8d6c9312.png" alt="寻找极值点"></p><h2 id="极值点精确定位" tabindex="-1"><a class="header-anchor" href="#极值点精确定位" aria-hidden="true">#</a> 极值点精确定位</h2><p>而我们找的的极值点是在高斯差分之后所确定下来的，那么其是属于离散空间上的点，不一定是真正意义上的极值点。</p><p>我们需用用到一条曲线来进行拟合。</p><p><img src="/Hello-Cpp/assets/DOG精确极值点.96a625a8.png" alt="精确极值点"></p><p>离散转换为连续，我们会想到泰勒展开式： $\begin{aligned} D(X)=D+\frac{\partial D^T}{\partial X}X+\frac{1}{2}X^T\frac{\partial^2 D}{\partial X^2}X \end{aligned}$</p><p>则极值点为 $\begin{aligned} \widetilde X=(x,y,\sigma)^T \end{aligned}$</p><h2 id="去除边缘影响" tabindex="-1"><a class="header-anchor" href="#去除边缘影响" aria-hidden="true">#</a> 去除边缘影响</h2><p>到这一步，得到的极值点是比较精确了，但不够准确。有些极值点不是我们想要的，当中就有一大部分是边缘区域产生的极值点。因为物体的边缘轮廓在灰度图中，存在着灰度值的突变，这样的点在计算中就被“误以为”是特征值。</p><p>仔细分析，边缘区域在纵向上灰度值突变很大，但是横向上的变化就很小了。好比你用黑笔在白纸上水平画一条线段。垂直方向看，黑色线与白色区域的突变很大。但是水平方向看时，黑色线上某一点的水平临近点仍然是黑点，突变程度非常小。</p><p>由于这一特殊性质，我们想到了Hessian矩阵，海塞矩阵是用来求曲率的，可以以函数的二阶偏导为元素，构成一个$2\times 2$的矩阵$H$ $\begin{aligned} H(x,y)= \begin{bmatrix} D_{xx}(x,y) &amp; D_{xy}(x,y) \ D_{xy}(x,y) &amp; D_{yy}(x,y) \end{bmatrix} \tag{1-1}<br> \end{aligned}$</p><blockquote><p>Harris角点检测算法</p></blockquote><h1 id="方向赋值" tabindex="-1"><a class="header-anchor" href="#方向赋值" aria-hidden="true">#</a> 方向赋值</h1><p>经过Harris角点检测算法之后，基本上得到了我们想要的精确特征点了。接下来我们就要求它们的方向。</p><p>在DOG 金字塔中，有很多层高斯模糊后的图像。在此，我们对其中一张图像的处理进行说明。当我们精确定位关键点后，需要找到该特征点对应的尺度值$σ$，根据这一尺度值，将对应的高斯图像的关键点进行有限差分，以$3×1.5σ$为半径的区域内图像梯度的幅角和幅值，得到： $\begin{aligned} m(x,y)=\sqrt{[L(x+1,y)-L(x-1,y)]^2+[L(x,y+1)-L(x,y-1)]^2} \end{aligned}$ $\begin{aligned} \theta(x,y)=\arctan(\frac{L(x,y+1)-L(x,y-1)}{L(x+1,y)-L(x-1,y)}) \end{aligned}$</p><p>然后利用直方图统计领域内像素对应的梯度和幅值：梯度方向角为横轴刻度，取45度为一个单位，那么横轴就有8个刻度；纵轴是对应梯度的幅值累加值。</p><p><img src="/Hello-Cpp/assets/方向赋值.8fddb292.png" alt="方向赋值"></p><p>取幅值最高的方向为主方向。有的时候，会出现第二峰值，因为有较多的关键点是多方向的。如果直接把它忽略掉不加以考虑的话，最后对匹配精度的影响还是蛮大的。</p><p>所以，为了匹配的稳定性，我们将超过峰值能量的百分之80的方向，称为辅方向。</p><h1 id="关键点描述" tabindex="-1"><a class="header-anchor" href="#关键点描述" aria-hidden="true">#</a> 关键点描述</h1><h2 id="确定描述子采样区域" tabindex="-1"><a class="header-anchor" href="#确定描述子采样区域" aria-hidden="true">#</a> 确定描述子采样区域</h2><p>到了这里，我们就已经得到赋值后的SIFT特征点了，其包含了位置，尺度，方向的信息。</p><p>接下来的要做的是：关键点的描述，即用一组向量将关键点描述出来。</p><p>SIFI 描述子$h(x, y,θ)$是对特征点附近邻域内高斯图像梯度统计结果的一种表示，它是一个三维的阵列，但通常将它表示成一个矢量。矢量是通过对三维阵列按一定规律进行排列得到的。特征描述子与特征点所在的尺度有关，因此，对梯度的求取应在特征点对应的高斯图像上进行。</p><p><img src="/Hello-Cpp/assets/确定描述子采样区域.e873ef03.png" alt="确定描述子采样区域"></p><h1 id="生成描述子" tabindex="-1"><a class="header-anchor" href="#生成描述子" aria-hidden="true">#</a> 生成描述子</h1><p>为了保证特征矢量具有旋转不变性，需要以特征点为中心，将特征点附近邻域内$(m\sigma(B_p+ 1)\sqrt{2} \times m\sigma(B_p+ 1)\sqrt{2})$图像梯度的位置和方向旋转一个方向角$θ$，即将原图像x轴转到与主方向相同的方向。</p><p>旋转公式如下： $\begin{aligned} \begin{bmatrix} x^<code> \\ y^</code> \end{bmatrix} = \begin{bmatrix} \cos\theta &amp; -\sin\theta \ \sin\theta &amp; \cos\theta \end{bmatrix} \begin{bmatrix} x \ y \end{bmatrix} \end{aligned}$</p><p>在特征点附近邻域图像梯度的位置和方向旋转后，再以特征点为中心，在旋转后的图像中取一个$mσB_p \times mσB_p$大小的图像区域。并将它等间隔划分成$B_p \times B_p$个子区域，每个间隔为$mσ$像元。</p><p><img src="/Hello-Cpp/assets/特征点附近邻域图像梯度的位置和方向旋转.1901320a.png" alt="特征点附近邻域图像梯度的位置和方向旋转"></p><p>到这里，有人会问：旋转过程中，中图和右图为什么每个像素点的方向不一样？其实，你要明确一点，你所选的小区域，是关键点旋转后的小区域，右图的区域跟旋转前的区域不一样了，右图是重新选取得区域，但是区域大小没变。</p><h1 id="生成特征匹配点" tabindex="-1"><a class="header-anchor" href="#生成特征匹配点" aria-hidden="true">#</a> 生成特征匹配点</h1><p>在每子区域内计算8个方向的梯度方向直方图，绘制每个梯度方向的累加值，形成一个种子点。与求特征点主方向时有所不同，此时，每个子区域的梯度方向直方图将0°~360°划分为8个方向范围，每个范围为45°，这样，每个种子点共有8个方向的梯度强度信息。由于存在4X4（Bp X Bp）个子区域，所以，共有4X4X8=128个数据，最终形成128维的SIFT特征矢量。同样，对于特征矢量需要进行高斯加权处理，加权采用方差为mσBp/2的标准高斯函数，其中距离为各点相对于特征点的距离。使用高斯权重的是为了防止位置微小的变化给特征向量带来很大的改变，并且给远离特征点的点赋予较小的权重，以防止错误的匹配。</p><p>在最后，对特征向量进行归一化处理，去除光照变化的影响。</p><h1 id="使用特征检测器" tabindex="-1"><a class="header-anchor" href="#使用特征检测器" aria-hidden="true">#</a> 使用特征检测器</h1><p>Opencv提供FeatureDetector实现特征点检测。</p><p>最后把所检测到的特征点放置在一个容器中，再进行后续的图像匹配工作。</p><p>至此，SIFT特征匹配算法讲解结束。</p><h1 id="代码部分" tabindex="-1"><a class="header-anchor" href="#代码部分" aria-hidden="true">#</a> 代码部分</h1><h2 id="opencv-函数" tabindex="-1"><a class="header-anchor" href="#opencv-函数" aria-hidden="true">#</a> OpenCV 函数</h2><div class="language-cpp ext-cpp line-numbers-mode"><pre class="language-cpp"><code>CV_WRAP <span class="token keyword">static</span> Ptr<span class="token operator">&lt;</span>SIFT<span class="token operator">&gt;</span> <span class="token function">create</span><span class="token punctuation">(</span>
    <span class="token keyword">int</span>     nfeatures <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> 
    <span class="token keyword">int</span>     nOctaveLayers <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
    <span class="token keyword">double</span>  contrastThreshold <span class="token operator">=</span> <span class="token number">0.04</span><span class="token punctuation">,</span> 
    <span class="token keyword">double</span>  edgeThreshold <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>
    <span class="token keyword">double</span>  sigma <span class="token operator">=</span> <span class="token number">1.6</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><p><code>nfeatures</code></p><ul><li>The number of best features to retain. The features are ranked by their scores (measured in SIFT algorithm as the local contrast)</li><li>保留的最佳特征的数量。特征按照得分进行排序（以 SIFT 算法作为局部对比度进行测量）</li></ul></li><li><p><code>nOctaveLayers</code></p><ul><li>The number of layers in each octave. 3 is the value used in D. Lowe paper. The number of octaves is computed automatically from the image resolution.</li><li>高斯金字塔的最小层级数。在 <code>D. Lowe</code> 的论文中使用的数值是 3 。octave 的数量是从图像分辨率中自动计算得出</li><li><blockquote><p>八度(octave) 简单地说八度就是在特定尺寸(长宽)下，经不同高斯核模糊的图像的集合。八度的集合是高斯金字塔。</p></blockquote></li></ul></li><li><p><code>contrastThreshold</code></p><ul><li>The contrast threshold used to filter out weak features in semi-uniform (low-contrast) regions. The larger the threshold, the less features are produced by the detector.</li><li>对比度阈值用来过滤掉弱特征的</li><li>@note The contrast threshold will be divided by nOctaveLayers when the filtering is applied. When nOctaveLayers is set to default and if you want to use the value used in D. Lowe paper, 0.03, set this argument to 0.09.</li></ul></li><li><p><code>edgeThreshold</code></p><ul><li>The threshold used to filter out edge-like features. Note that the its meaning is different from the contrastThreshold, i.e. the larger the edgeThreshold, the less features are filtered out (more features are retained).</li></ul></li><li><p><code>sigma</code></p><ul><li>The sigma of the Gaussian applied to the input image at the octave #0. If your image is captured with a weak camera with soft lenses, you might want to reduce the number.</li><li>$\sigma$, 高斯输入层级， 如果图像分辨率较低，则可能需要减少数值</li></ul></li></ul><div class="language-cpp ext-cpp line-numbers-mode"><pre class="language-cpp"><code>CV_WRAP <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">detect</span><span class="token punctuation">(</span> 
  InputArray image<span class="token punctuation">,</span>
  CV_OUT std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>KeyPoint<span class="token operator">&gt;</span><span class="token operator">&amp;</span> keypoints<span class="token punctuation">,</span>
  InputArray mask<span class="token operator">=</span><span class="token function">noArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>@brief Detects keypoints in an image (first variant) or image set (second variant).</p><ul><li><code>image</code> Image.</li><li><code>keypoints</code> The detected keypoints. In the second variant of the method keypoints[i] is a set of keypoints detected in images[i] .</li><li><code>mask</code> Mask specifying where to look for keypoints (optional). It must be a 8-bit integer matrix with non-zero values in the region of interest.</li></ul><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h1><ul><li><a href="https://blog.csdn.net/sxlsxl119/article/details/84814580" target="_blank" rel="noopener noreferrer">OpenCV-图像特征提取算法5_SIFT<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://blog.csdn.net/weixin_38404120/article/details/73740612" target="_blank" rel="noopener noreferrer">SIFT特征匹配算法介绍——寻找图像特征点的原理<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://blog.csdn.net/lyl771857509/article/details/79675137" target="_blank" rel="noopener noreferrer">SIFT算法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><p><a href="#%E5%AF%BC%E8%88%AA">回到目录</a></p><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/HenryZhuHR/Hello-Cpp/edit/main/3rd_patry/opencv/sift/sift.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 38650110+HenryZhuHR@users.noreply.github.com">Henry Zhu</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/Hello-Cpp/assets/app.2859fef2.js" defer></script>
  </body>
</html>
